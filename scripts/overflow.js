const { ethers } = require("hardhat")

async function checkIntegerOverflow(contractAddress, abi) {
    const provider = new ethers.providers.JsonRpcProvider(
        "http://127.0.0.1:8545/"
    )

    const contract = new ethers.Contract(contractAddress, abi, provider)

    const stateVariables = abi.filter(
        (item) =>
            item.type === "variable" &&
            item.stateMutability === "nonpayable" &&
            item.outputs[0].type.includes("uint")
    )

    console.log(
        `Checking integer overflow vulnerability for contract ${contractAddress}...`
    )
    const results = []
    for (let i = 0; i < stateVariables.length; i++) {
        const variable = stateVariables[i]
        const functionName =
            "set" +
            variable.name.charAt(0).toUpperCase() +
            variable.name.slice(1)
        const maxValue = variable.outputs[0].type.includes("256")
            ? ethers.constants.MaxUint256
            : ethers.utils.parseUnits(
                  "100",
                  variable.outputs[0].type.split("uint")[1]
              )
        const tx = await contract[functionName](maxValue)
        await tx.wait()

        const currentValue = await contract[variable.name]()
        if (currentValue.eq(maxValue)) {
            results.push(`${variable.name} passed the overflow test!`)
        } else {
            results.push(
                `!!! ${variable.name} may have overflow vulnerability !!!`
            )
        }
    }
    console.log(results.join("\n"))
    console.log("-------------------------------------------------------")
}

async function main() {
    const provider = new ethers.providers.JsonRpcProvider(
        "http://127.0.0.1:8545/"
    )
    console.log(provider)
    const contractAddresses = []
    const accounts = await provider.listAccounts()
    for (const account of accounts) {
        const code = await provider.getCode(account)
        if (code !== "0x") {
            contractAddresses.push(account)
        }
    }
    console.log(
        `Found ${contractAddresses.length} contracts on the localhost network.\n`
    )

    for (let i = 0; i < contractAddresses.length; i++) {
        const contractAddress = contractAddresses[i]
        const abi = await provider.getContractABI(contractAddress)
        await checkIntegerOverflow(contractAddress, abi)
        await checkReentrancy(contractAddress, abi)
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error)
        process.exit(1)
    })
