const { ethers } = require("hardhat")

async function checkIntegerOverflow(contractAddress, abi) {
    const provider = new ethers.providers.JsonRpcProvider()
    const contract = new ethers.Contract(contractAddress, abi, provider)

    const stateVariables = abi.filter(
        (item) =>
            item.type === "variable" &&
            item.stateMutability === "nonpayable" &&
            item.outputs[0].type.includes("uint")
    )

    console.log(
        `Checking integer overflow vulnerability for contract ${contractAddress}...`
    )
    const results = []
    for (let i = 0; i < stateVariables.length; i++) {
        const variable = stateVariables[i]
        const functionName =
            "set" +
            variable.name.charAt(0).toUpperCase() +
            variable.name.slice(1)
        const maxValue = variable.outputs[0].type.includes("256")
            ? ethers.constants.MaxUint256
            : ethers.utils.parseUnits(
                  "100",
                  variable.outputs[0].type.split("uint")[1]
              )
        const tx = await contract[functionName](maxValue)
        await tx.wait()

        const currentValue = await contract[variable.name]()
        if (currentValue.eq(maxValue)) {
            results.push(`${variable.name} passed the overflow test!`)
        } else {
            results.push(
                `!!! ${variable.name} may have overflow vulnerability !!!`
            )
        }
    }
    console.log(results.join("\n"))
    console.log("-------------------------------------------------------")
}

async function checkReentrancy(contractAddress, abi) {
    const provider = new ethers.providers.JsonRpcProvider()
    const contract = new ethers.Contract(contractAddress, abi, provider)

    console.log(
        `Checking reentrancy vulnerability for contract ${contractAddress}...`
    )
    const vulnerableFunctions = abi.filter(
        (item) => item.stateMutability === "payable"
    )
    for (let i = 0; i < vulnerableFunctions.length; i++) {
        const functionName = vulnerableFunctions[i].name
        const tx = { to: contractAddress, value: ethers.utils.parseEther("1") }
        await contract[functionName](tx)
    }
    console.log("Reentrancy test completed.")
    console.log("-------------------------------------------------------")
}

async function main() {
    const provider = new ethers.providers.JsonRpcProvider()
    const contractAddresses = await provider.listAccounts() // 获取本地节点上所有合约地址
    console.log(
        `Found ${contractAddresses.length} contracts on the localhost network.\n`
    )

    for (let i = 0; i < contractAddresses.length; i++) {
        const contractAddress = contractAddresses[i]
        const abi = await provider.getContractABI(contractAddress)
        await checkIntegerOverflow(contractAddress, abi)
        await checkReentrancy(contractAddress, abi)
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error)
        process.exit(1)
    })
