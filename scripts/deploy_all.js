// 该脚本部署和测试一组Solidity智能合约中的整数溢出漏洞，具体步骤如下：

// 编译合约名称列表。
// 部署每个合约并打印其地址。
// 对于每个合约，标识所有无符号整数状态变量。
// 创建一个新账户并给其充值1 ETH。
// 对于合约中的每个无符号整数状态变量，计算在发生溢出之前可以添加的最大值。
// 发送一个交易以将最大值添加到变量中。
// 如果交易失败，则打印错误消息表明合约不易受整数溢出攻击。
// 如果交易成功，则打印一条消息表明合约易受整数溢出攻击。
// 请注意，该脚本使用Hardhat框架来编译和部署合约，并与以太坊网络进行交互。它还依赖于环境变量来存储在脚本中使用的账户的地址和私钥。

const hre = require("hardhat")
const { ethers, JsonRpcProvider } = require("hardhat")
const { utils } = require("ethers")
require("dotenv").config()

async function main() {
    // Compile the contracts
    await hre.run("compile")

    // Get the list of contract names
    const contractNames = [
        "swc101_1",
        "swc101_2",
        "swc101_3",
        "swc101_4",
        "swc101_5",
        "swc101_6",
        "swc101_7",
        "swc101_8",
        "swc101_9",
        "swc101_10",
    ]

    // Deploy each contract
    for (let i = 0; i < contractNames.length; i++) {
        const contractName = contractNames[i]

        console.log(`Deploying ${contractName}...`)

        // Get the ContractFactory for the contract
        const Contract = await ethers.getContractFactory(contractName)

        // Deploy the contract
        const contract = await Contract.deploy()

        // Wait for the contract to be deployed
        await contract.deployed()

        console.log(`${contractName} deployed to: ${contract.address}`)

        // Get all the unsigned integer state variables
        const abi = contract.interface
        const stateVariables = abi.fragments.filter(
            (x) =>
                x.type === "variable" &&
                x.stateMutability === "nonpayable" &&
                x.typeName.type === "uint256"
        )
        const variableNames = stateVariables.map((x) => x.name)

        console.log(`State variables: ${variableNames.join(", ")}`)

        // Create a new account and fund it with ETH
        const attackerWallet = ethers.Wallet.createRandom()
        const attackerAddress = attackerWallet.address
        console.log(`Attacker address: ${attackerAddress}`)

        const fundingAmount = ethers.utils.parseEther("1")
        const value = fundingAmount.toNumber()

        await hre.network.provider.request({
            method: "hardhat_impersonateAccount",
            params: [process.env.FORK_ACCOUNT],
        })

        const signer = await ethers.provider.getSigner(process.env.FORK_ACCOUNT)

        await hre.network.provider.send("eth_sendTransaction", [
            {
                from: process.env.FORK_ACCOUNT,
                to: attackerAddress,
                value: value,
            },
        ])

        console.log(`Funded attacker account with ${fundingAmount} ETH`)

        // Send transactions to test for integer overflow
        for (let j = 0; j < variableNames.length; j++) {
            const variableName = variableNames[j]

            console.log(
                `Testing for integer overflow on variable ${variableName}...`
            )

            // Get the current value of the variable
            const currentValue = await contract[variableName]()

            // Calculate the maximum value of the variable
            const maxUint256 = ethers.constants.MaxUint256
            const maxValue = maxUint256.sub(currentValue)

            console.log(`Current value: ${currentValue}`)
            console.log(`Maximum value: ${maxValue}`)

            // Send a transaction to trigger the integer overflow
            try {
                const tx = await contract[variableName]
                    .connect(attackerWallet)
                    .add(maxValue)

                console.log(`Transaction sent: ${tx.hash}`)
            } catch (e) {
                console.log(`Error sending transaction: ${e}`)
            }
        }

        // Check if the contract was successfully attacked
        const isVulnerable = await contract.isVulnerable()

        console.log(
            `${contractName} is ${
                isVulnerable ? "vulnerable" : "not vulnerable"
            }`
        )
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error)
        process.exit(1)
    })
